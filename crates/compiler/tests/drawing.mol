enum Option<T> {
    Some { value: T },
    None
}

trait Iterable<T> {
    fn iter(self) -> T;
}

trait Iterator<T> {
    fn next(self) -> Option<T>;
}

impl<T> T[] {
    fn size(self) -> uint_size {
        get_size(self)
    }
}

struct ArrayIter<T> {
    value: T[],
    index: uint_size
}

impl<T> trait Iterator<T> for ArrayIter<T> {
    fn next(self) -> Option<T> {
        if self.index == get_size(self.value) {
            Option::None<T>
        } else {
            const returned = self.value[self.index];

            self.index = self.index + 1uint_size;

            Option::Some<T> {
                value: returned
            }
        }
    }
}

impl<T> trait Iterable<ArrayIter<T>> for T[] {
    fn iter(self) -> ArrayIter<T> {
        ArrayIter {
            value: self,
            index: 0
        }
    }
}

struct Constraints {
    min_width: float = 0.0,
    max_width: float = 0.0,
    min_height: float = 0.0,
    max_height: float = 0.0,
}

trait Placeable {
    fn get_name(self) -> string;
    
    fn get_width(self) -> float;
    fn get_height(self) -> float;

    fn get_measured_width(self) -> float;
    fn get_measured_height(self) -> float;

    fn place(self, x: float, y: float);
    fn render(self, ctx: DrawContext);
}

struct PlaceableComponent {
    measured_width: float,
    measured_height: float,
    comp: Placeable
}

trait Measurable {
    fn measure(self, constraints: Constraints) -> PlaceableComponent;
}

struct MeasureResult {
    width: float,
    height: float,
    placeables: Placeable[],
    place_children: fn(Placeable[])
}

declare Layout {
    measure: fn(Measurable[], Constraints),
    children: Measurable[]
}

declare Rectangle {
    x: float,
    y: float,
    width: float,
    height: float,
    color: uint32
}

impl trait Placeable for Rectangle {
    fn get_name(self) -> string {
        "rectangle"
    }
    
    fn get_width(self) -> float {
        self.width
    }

    fn get_height(self) -> float {
        self.height
    }

    fn get_measured_width(self) -> float {
        self.width
    }

    fn get_measured_height(self) -> float {
        self.height
    }


    fn place(self, x: float, y: float) {
        self.x = x;
        self.y = y;
    }

    fn render(self, ctx: DrawContext) {
        ctx.draw_rect(self.x, self.y, self.width, self.height, Color { red: 0, green: 255, blue: 0 });
    }
}

impl trait Measurable for Rectangle {
    fn measure(self, constraints: Constraints) -> PlaceableComponent {
        const measured_width = if self.width < constraints.min_width {
            constraints.min_width
        } else if self.width > constraints.max_width {
            constraints.max_width
        } else {
            self.width
        };

        const measured_height = if self.height < constraints.min_height {
            constraints.min_height
        } else if self.height > constraints.max_height {
            constraints.max_height
        } else {
            self.height
        };

        PlaceableComponent {
            measured_width: measured_width,
            measured_height: measured_height,
            comp: self
        }
    }
}

declare Container {
    vertical: boolean,
    width: float = 0.0,
    height: float = 0.0,
    children: Placeable[]
}

impl trait Placeable for Container {
    fn get_name(self) -> string {
        "container"
    }
    
    fn get_width(self) -> float {
        self.width
    }

    fn get_height(self) -> float {
        self.height
    }

    fn get_measured_width(self) -> float {
        self.width
    }

    fn get_measured_height(self) -> float {
        self.height
    }

    fn place(self, x: float, y: float) {
        let offset = if self.vertical { y } else { x };
        let iterator = self.children.iter();

        while iterator.next() is Option::Some { value } {
            if self.vertical {
                value.place(x, offset);
            } else {
                value.place(offset, y);
            }

            if value is Rectangle rect {
                offset = offset + if self.vertical { rect.height } else { rect.width };
            }
        }
    }

    fn render(self, ctx: DrawContext) {
        let iterator = self.children.iter();

        while iterator.next() is Option::Some { value } {
            value.render(ctx);
        }
    }
}

fn call_me() {
    println_str("function was called!");
}

fn call_it(callable: fn() -> string) {
    println_str(callable());
}

fn main(context: DrawContext) {
    const contained = Container {
        vertical: true,
        
        Rectangle {
            x: 0.0,
            y: 0.0,
            width: 128.0,
            height: 256.0,
            color: 0xFFFF00
        }
        
        Rectangle {
            x: 24.0,
            y: 0.0,
            width: 256.0,
            height: 128.0,
            color: 0xFFFF00
        }
    };

    context.draw_rect(4.0, 4.0, 24.0, 24.0, Color { red: 0, green: 255, blue: 0 });

    contained.place(0.0, 0.0);
    contained.render(context);

    const layout = Layout {
        measure: |measurables, constraints| {
            let iterator = measurables.iter();

            while iterator.next() is Option::Some { value } {
                const placeable = value.measure(constraints);
            }
        },

        Rectangle {
            x: 0.0,
            y: 0.0,
            width: 128.0,
            height: 256.0,
            color: 0xFFFF00
        }
        
        Rectangle {
            x: 24.0,
            y: 0.0,
            width: 256.0,
            height: 128.0,
            color: 0xFFFF00
        }
    };

    layout.measure(layout.children, Constraints { max_width: 64.0 });

    if contained.children[0] is Rectangle rect {
        const placeable = rect.measure(Constraints { max_width: 64.0 });

        println_float(placeable.measured_width);
    }

    call_me();
    call_it(|| { "it was called" });
    call_it(|| { "it was called again!" });
}
